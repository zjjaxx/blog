## Django

### 项目文件说明

- `项目名/__init__.py`：空文件，告诉Python解释器这个目录应该被视为一个Python的包。
- `项目名/settings.py`：Django项目的配置文件。
- `项目名/urls.py`：Django项目的URL映射声明，就像是网站的“目录”。
- `项目名/wsgi.py`：项目运行在WSGI兼容Web服务器上的入口文件。
- `manage.py`： 管理Django项目的脚本程序。

### 修改项目的配置文件`settings.py`。

Django是一个支持国际化和本地化的框架，因此刚才我们看到的Django项目的默认首页也是支持国际化的，我们可以通过修改配置文件将默认语言修改为中文，时区设置为东八区。

```python
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
```

修改为以下内容。

```python
LANGUAGE_CODE = "zh-hans"
TIME_ZONE = "Asia/Shanghai"
```

### 创建自己的应用

如果要开发自己的Web应用，需要先在Django项目中创建“应用”，一个Django项目可以包含一个或多个应用。

1. 在PyCharm的终端中执行下面的命令，创建名为`first`的应用。

```bash
python manage.py startapp first
```

执行上面的命令会在当前路径下创建`first`目录，其目录结构如下所示：

- `__init__.py`：一个空文件，告诉Python解释器这个目录应该被视为一个Python的包。
- `admin.py`：可以用来注册模型，用于在Django框架自带的管理后台中管理模型。
- `apps.py`：当前应用的配置文件。
- migrations：存放与模型有关的数据库迁移信息。
  - `__init__.py`：一个空文件，告诉Python解释器这个目录应该被视为一个Python的包。

- `models.py`：存放应用的数据模型（MTV中的M）。
- `tests.py`：包含测试应用各项功能的测试类和测试函数。
- `views.py`：处理用户HTTP请求并返回HTTP响应的函数或类（MTV中的V）。

### 模型

模型准确且唯一的描述了数据。它包含您储存的数据的重要字段和行为。一般来说，每一个模型都映射一张数据库表。

```python
from django.db import models


class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
```

上面的 `Person` 模型会创建一个如下的数据库表：

```python
CREATE TABLE myapp_person (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(30) NOT NULL
);
```

一些技术上的说明：

- 该表的名称 `myapp_person` 是自动从某些模型元数据中派生出来，但可以被改写。参阅 [表名称](https://docs.djangoproject.com/zh-hans/5.2/ref/models/options/#table-names) 获取更多信息。
- 一个 `id` 字段会被自动添加，但是这种行为可以被改写。请参阅 [自动设置主键](https://docs.djangoproject.com/zh-hans/5.2/topics/db/models/#automatic-primary-key-fields)。

#### 使用模型

一旦你定义了你的模型，你需要告诉 Django 你准备 *使用* 这些模型。你需要修改设置文件中的 [`INSTALLED_APPS`](https://docs.djangoproject.com/zh-hans/5.2/ref/settings/#std-setting-INSTALLED_APPS) ，在这个设置中添加包含 `models.py` 文件的模块名称。

例如，若模型位于项目中的 `myapp.models` 模块（ 此包结构由 [`manage.py startapp`](https://docs.djangoproject.com/zh-hans/5.2/ref/django-admin/#django-admin-startapp) 命令创建）， [`INSTALLED_APPS`](https://docs.djangoproject.com/zh-hans/5.2/ref/settings/#std-setting-INSTALLED_APPS) 应设置如下：

```python
INSTALLED_APPS = [
    # ...
    "myapp",
    # ...
]
```

#### 字段类型

模型中每一个字段都应该是某个 [`Field`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field) 类的实例， Django 利用这些字段类来实现以下功能：

你可以在 [模型字段参考](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#model-field-types) 中看到完整列表

##### 常用的字段列表

######  `AutoField`

一个 [`IntegerField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.IntegerField)，根据可用的 ID 自动递增。你通常不需要直接使用它；如果你没有指定，主键字段会自动添加到你的模型中。

###### `BooleanField`

一个 true／false 字段。

###### `CharField`

一个字符串字段，适用于小到大的字符串。

对于大量的文本，使用 [`TextField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.TextField)。

[`CharField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.CharField) 具有以下额外参数：CharField.max_length

###### `DateField`

- DateField.auto_now

  每次保存对象时，自动将该字段设置为现在。对于“最后修改”的时间戳很有用。请注意，当前日期 *总是* 被使用，而不仅仅是一个你可以覆盖的默认值。只有在调用 [`Model.save()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/instances/#django.db.models.Model.save) 时，该字段才会自动更新。当以其他方式对其他字段进行更新时，如 [`QuerySet.update()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet.update)，该字段不会被更新，尽管你可以在这样的更新中为该字段指定一个自定义值。

- DateField.auto_now_add

  当第一次创建对象时，自动将该字段设置为现在。对创建时间戳很有用。请注意，当前日期是 *始终* 使用的；它不是一个你可以覆盖的默认值。因此，即使你在创建对象时为该字段设置了一个值，它也会被忽略。

###### `DateTimeField`

一个日期和时间，在 Python 中用一个 `datetime.datetime` 实例表示。与 [`DateField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.DateField) 一样，使用相同的额外参数。

###### `EmailField`

一个 [`CharField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.CharField)，使用 [`EmailValidator`](https://docs.djangoproject.com/zh-hans/5.2/ref/validators/#django.core.validators.EmailValidator) 来检查该值是否为有效的电子邮件地址。

###### `FloatField`

在 Python 中用一个 `float` 实例表示的浮点数。

###### `IntegerField`

一个整数。其值仅允许在特定范围内（取决于数据库）。在Django支持的所有数据库中，-2147483648到2147483647之间的值都是兼容的

###### `JSONField`

一个用于存储 JSON 编码数据的字段。

###### `TextField`

一个大的文本字段。

###### `TimeField`

一个时间，

###### `URLField`

该字段的默认表单部件是一个 [`URLInput`](https://docs.djangoproject.com/zh-hans/5.2/ref/forms/widgets/#django.forms.URLInput)。

###### `UUIDField`

通用唯一标识符是 [`primary_key`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.primary_key) 的 [`AutoField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.AutoField) 的一个很好的替代方案。数据库不会为你生成 UUID，所以建议使用 [`default`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.default) ：

```python
import uuid
from django.db import models


class MyUUIDModel(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    # other fields
```

##### 关系字段

###### ForeignKey

多对一关系。需要两个位置参数：模型关联的类和 [`on_delete`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ForeignKey.on_delete) 选项：

```python
from django.db import models


class Manufacturer(models.Model):
    name = models.TextField()


class Car(models.Model):
    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)
```

第一个位置参数可以是具体模型类或对模型类的 [延迟引用](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#lazy-relationships)。还支持 [递归关系](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#recursive-relationships)，即模型与自身的关系。

第二个位置参数级联删除。Django模拟了SQL约束ON DELETE CASCADE的行为，并且还会删除包含ForeignKey的对象。

###### `ManyToManyField`

一个多对多的关系。需要一个位置参数：模型相关的类，它的工作原理与 [`ForeignKey`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ForeignKey) 完全相同，包括 [递归](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#recursive-relationships) 和 [惰性](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#lazy-relationships) 关系。

###### `OneToOneField`

一对一的关系。

#### 字段选项

下面介绍一部分经常用到的通用参数：

##### [`null`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.null)

如果设置为 `True`，当该字段为空时，Django 会将数据库中该字段设置为 `NULL`。默认为 `False` 。

##### [`blank`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.blank)

如果设置为 `True`，该字段允许为空。默认为 `False`。

请注意，这与 [`null`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.null) 不同。[`null`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.null) 完全与数据库相关联，而 [`blank`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.blank) 与验证有关。如果字段具有 [`blank=True`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.blank)，表单验证将允许输入空值。如果字段具有 [`blank=False`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.blank)，则字段为必填项。

##### [`choices`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.choices)

一个由二元组组成的序列、映射、枚举类型或可调用对象（无需参数并返回上述任意格式），用作该字段的选项。如果提供了此参数，默认的表单控件将变为选择框而非标准文本框，并将选项限制为给定的选项

```python
YEAR_IN_SCHOOL_CHOICES = [
    ("FR", "Freshman"),
    ("SO", "Sophomore"),
    ("JR", "Junior"),
    ("SR", "Senior"),
    ("GR", "Graduate"),
]
```

每个二元组的第一个值会储存在数据库中，而第二个值将只会用于在表单中显示。

对于一个模型实例，要获取该字段二元组中相对应的第二个值，使用 [`get_FOO_display()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/instances/#django.db.models.Model.get_FOO_display) 方法。例如：

```python
from django.db import models


class Person(models.Model):
    SHIRT_SIZES = {
        "S": "Small",
        "M": "Medium",
        "L": "Large",
    }
    name = models.CharField(max_length=60)
    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)
```

```python
>>> p = Person(name="Fred Flintstone", shirt_size="L")
>>> p.save()
>>> p.shirt_size
'L'
>>> p.get_shirt_size_display()
'Large'
```

##### [`default`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.default)

该字段的默认值。可以是一个值或者是个可调用的对象，如果是个可调用对象，每次实例化模型时都会调用该对象。

##### [`primary_key`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.primary_key)

如果设置为 `True` ，将该字段设置为该模型的主键

##### [`unique`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.unique)

如果设置为 `True`，这个字段的值必须在整个表中保持唯一。

#### 字段备注名

除了 [`ForeignKey`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ForeignKey)， [`ManyToManyField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ManyToManyField) 和 [`OneToOneField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.OneToOneField)，任何字段类型都接收一个可选的位置参数 [`verbose_name`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.verbose_name)，如果未指定该参数值， Django 会自动使用字段的属性名作为该参数值，并且把下划线转换为空格。

```python
first_name = models.CharField("person's first name", max_length=30)
```

#### 关联关系

## Django

### 项目文件说明

- `项目名/__init__.py`：空文件，告诉Python解释器这个目录应该被视为一个Python的包。
- `项目名/settings.py`：Django项目的配置文件。
- `项目名/urls.py`：Django项目的URL映射声明，就像是网站的“目录”。
- `项目名/wsgi.py`：项目运行在WSGI兼容Web服务器上的入口文件。
- `manage.py`： 管理Django项目的脚本程序。

### 修改项目的配置文件`settings.py`。

Django是一个支持国际化和本地化的框架，因此刚才我们看到的Django项目的默认首页也是支持国际化的，我们可以通过修改配置文件将默认语言修改为中文，时区设置为东八区。

```python
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
```

修改为以下内容。

```python
LANGUAGE_CODE = "zh-hans"
TIME_ZONE = "Asia/Shanghai"
```

### 创建自己的应用

如果要开发自己的Web应用，需要先在Django项目中创建“应用”，一个Django项目可以包含一个或多个应用。

1. 在PyCharm的终端中执行下面的命令，创建名为`first`的应用。

```bash
python manage.py startapp first
```

执行上面的命令会在当前路径下创建`first`目录，其目录结构如下所示：

- `__init__.py`：一个空文件，告诉Python解释器这个目录应该被视为一个Python的包。
- `admin.py`：可以用来注册模型，用于在Django框架自带的管理后台中管理模型。
- `apps.py`：当前应用的配置文件。
- migrations：存放与模型有关的数据库迁移信息。
  - `__init__.py`：一个空文件，告诉Python解释器这个目录应该被视为一个Python的包。

- `models.py`：存放应用的数据模型（MTV中的M）。
- `tests.py`：包含测试应用各项功能的测试类和测试函数。
- `views.py`：处理用户HTTP请求并返回HTTP响应的函数或类（MTV中的V）。

### 模型

模型准确且唯一的描述了数据。它包含您储存的数据的重要字段和行为。一般来说，每一个模型都映射一张数据库表。

```python
from django.db import models


class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
```

上面的 `Person` 模型会创建一个如下的数据库表：

```python
CREATE TABLE myapp_person (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(30) NOT NULL
);
```

一些技术上的说明：

- 该表的名称 `myapp_person` 是自动从某些模型元数据中派生出来，但可以被改写。参阅 [表名称](https://docs.djangoproject.com/zh-hans/5.2/ref/models/options/#table-names) 获取更多信息。
- 一个 `id` 字段会被自动添加，但是这种行为可以被改写。请参阅 [自动设置主键](https://docs.djangoproject.com/zh-hans/5.2/topics/db/models/#automatic-primary-key-fields)。

#### 使用模型

一旦你定义了你的模型，你需要告诉 Django 你准备 *使用* 这些模型。你需要修改设置文件中的 [`INSTALLED_APPS`](https://docs.djangoproject.com/zh-hans/5.2/ref/settings/#std-setting-INSTALLED_APPS) ，在这个设置中添加包含 `models.py` 文件的模块名称。

例如，若模型位于项目中的 `myapp.models` 模块（ 此包结构由 [`manage.py startapp`](https://docs.djangoproject.com/zh-hans/5.2/ref/django-admin/#django-admin-startapp) 命令创建）， [`INSTALLED_APPS`](https://docs.djangoproject.com/zh-hans/5.2/ref/settings/#std-setting-INSTALLED_APPS) 应设置如下：

```python
INSTALLED_APPS = [
    # ...
    "myapp",
    # ...
]
```

#### 字段类型

模型中每一个字段都应该是某个 [`Field`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field) 类的实例， Django 利用这些字段类来实现以下功能：

你可以在 [模型字段参考](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#model-field-types) 中看到完整列表

##### 常用的字段列表

######  `AutoField`

一个 [`IntegerField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.IntegerField)，根据可用的 ID 自动递增。你通常不需要直接使用它；如果你没有指定，主键字段会自动添加到你的模型中。

###### `BooleanField`

一个 true／false 字段。

###### `CharField`

一个字符串字段，适用于小到大的字符串。

对于大量的文本，使用 [`TextField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.TextField)。

[`CharField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.CharField) 具有以下额外参数：CharField.max_length

###### `DateField`

- DateField.auto_now

  每次保存对象时，自动将该字段设置为现在。对于“最后修改”的时间戳很有用。请注意，当前日期 *总是* 被使用，而不仅仅是一个你可以覆盖的默认值。只有在调用 [`Model.save()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/instances/#django.db.models.Model.save) 时，该字段才会自动更新。当以其他方式对其他字段进行更新时，如 [`QuerySet.update()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet.update)，该字段不会被更新，尽管你可以在这样的更新中为该字段指定一个自定义值。

- DateField.auto_now_add

  当第一次创建对象时，自动将该字段设置为现在。对创建时间戳很有用。请注意，当前日期是 *始终* 使用的；它不是一个你可以覆盖的默认值。因此，即使你在创建对象时为该字段设置了一个值，它也会被忽略。

###### `DateTimeField`

一个日期和时间，在 Python 中用一个 `datetime.datetime` 实例表示。与 [`DateField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.DateField) 一样，使用相同的额外参数。

###### `EmailField`

一个 [`CharField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.CharField)，使用 [`EmailValidator`](https://docs.djangoproject.com/zh-hans/5.2/ref/validators/#django.core.validators.EmailValidator) 来检查该值是否为有效的电子邮件地址。

###### `FloatField`

在 Python 中用一个 `float` 实例表示的浮点数。

###### `IntegerField`

一个整数。其值仅允许在特定范围内（取决于数据库）。在Django支持的所有数据库中，-2147483648到2147483647之间的值都是兼容的

###### `JSONField`

一个用于存储 JSON 编码数据的字段。

###### `TextField`

一个大的文本字段。

###### `TimeField`

一个时间，

###### `URLField`

该字段的默认表单部件是一个 [`URLInput`](https://docs.djangoproject.com/zh-hans/5.2/ref/forms/widgets/#django.forms.URLInput)。

###### `UUIDField`

通用唯一标识符是 [`primary_key`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.primary_key) 的 [`AutoField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.AutoField) 的一个很好的替代方案。数据库不会为你生成 UUID，所以建议使用 [`default`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.default) ：

```python
import uuid
from django.db import models


class MyUUIDModel(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    # other fields
```

##### 关系字段

###### ForeignKey

多对一关系。需要两个位置参数：模型关联的类和 [`on_delete`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ForeignKey.on_delete) 选项：

```python
from django.db import models


class Manufacturer(models.Model):
    name = models.TextField()


class Car(models.Model):
    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)
```

第一个位置参数可以是具体模型类或对模型类的 [延迟引用](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#lazy-relationships)。还支持 [递归关系](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#recursive-relationships)，即模型与自身的关系。

第二个位置参数级联删除。Django模拟了SQL约束ON DELETE CASCADE的行为，并且还会删除包含ForeignKey的对象。

###### `ManyToManyField`

一个多对多的关系。需要一个位置参数：模型相关的类，它的工作原理与 [`ForeignKey`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ForeignKey) 完全相同，包括 [递归](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#recursive-relationships) 和 [惰性](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#lazy-relationships) 关系。

###### `OneToOneField`

一对一的关系。

#### 字段选项

下面介绍一部分经常用到的通用参数：

##### [`null`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.null)

如果设置为 `True`，当该字段为空时，Django 会将数据库中该字段设置为 `NULL`。默认为 `False` 。

##### [`blank`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.blank)

如果设置为 `True`，该字段允许为空。默认为 `False`。

请注意，这与 [`null`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.null) 不同。[`null`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.null) 完全与数据库相关联，而 [`blank`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.blank) 与验证有关。如果字段具有 [`blank=True`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.blank)，表单验证将允许输入空值。如果字段具有 [`blank=False`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.blank)，则字段为必填项。

##### [`choices`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.choices)

一个由二元组组成的序列、映射、枚举类型或可调用对象（无需参数并返回上述任意格式），用作该字段的选项。如果提供了此参数，默认的表单控件将变为选择框而非标准文本框，并将选项限制为给定的选项

```python
YEAR_IN_SCHOOL_CHOICES = [
    ("FR", "Freshman"),
    ("SO", "Sophomore"),
    ("JR", "Junior"),
    ("SR", "Senior"),
    ("GR", "Graduate"),
]
```

每个二元组的第一个值会储存在数据库中，而第二个值将只会用于在表单中显示。

对于一个模型实例，要获取该字段二元组中相对应的第二个值，使用 [`get_FOO_display()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/instances/#django.db.models.Model.get_FOO_display) 方法。例如：

```python
from django.db import models


class Person(models.Model):
    SHIRT_SIZES = {
        "S": "Small",
        "M": "Medium",
        "L": "Large",
    }
    name = models.CharField(max_length=60)
    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)
```

```python
>>> p = Person(name="Fred Flintstone", shirt_size="L")
>>> p.save()
>>> p.shirt_size
'L'
>>> p.get_shirt_size_display()
'Large'
```

##### [`default`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.default)

该字段的默认值。可以是一个值或者是个可调用的对象，如果是个可调用对象，每次实例化模型时都会调用该对象。

##### [`primary_key`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.primary_key)

如果设置为 `True` ，将该字段设置为该模型的主键

##### [`unique`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.unique)

如果设置为 `True`，这个字段的值必须在整个表中保持唯一。

#### 字段备注名

除了 [`ForeignKey`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ForeignKey)， [`ManyToManyField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ManyToManyField) 和 [`OneToOneField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.OneToOneField)，任何字段类型都接收一个可选的位置参数 [`verbose_name`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.verbose_name)，如果未指定该参数值， Django 会自动使用字段的属性名作为该参数值，并且把下划线转换为空格。

```python
first_name = models.CharField("person's first name", max_length=30)
```

#### 关联关系

## Django

### 项目文件说明

- `项目名/__init__.py`：空文件，告诉Python解释器这个目录应该被视为一个Python的包。
- `项目名/settings.py`：Django项目的配置文件。
- `项目名/urls.py`：Django项目的URL映射声明，就像是网站的“目录”。
- `项目名/wsgi.py`：项目运行在WSGI兼容Web服务器上的入口文件。
- `manage.py`： 管理Django项目的脚本程序。

### 修改项目的配置文件`settings.py`。

Django是一个支持国际化和本地化的框架，因此刚才我们看到的Django项目的默认首页也是支持国际化的，我们可以通过修改配置文件将默认语言修改为中文，时区设置为东八区。

```python
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
```

修改为以下内容。

```python
LANGUAGE_CODE = "zh-hans"
TIME_ZONE = "Asia/Shanghai"
```

### 创建自己的应用

如果要开发自己的Web应用，需要先在Django项目中创建“应用”，一个Django项目可以包含一个或多个应用。

1. 在PyCharm的终端中执行下面的命令，创建名为`first`的应用。

```bash
python manage.py startapp first
```

执行上面的命令会在当前路径下创建`first`目录，其目录结构如下所示：

- `__init__.py`：一个空文件，告诉Python解释器这个目录应该被视为一个Python的包。
- `admin.py`：可以用来注册模型，用于在Django框架自带的管理后台中管理模型。
- `apps.py`：当前应用的配置文件。
- migrations：存放与模型有关的数据库迁移信息。
  - `__init__.py`：一个空文件，告诉Python解释器这个目录应该被视为一个Python的包。

- `models.py`：存放应用的数据模型（MTV中的M）。
- `tests.py`：包含测试应用各项功能的测试类和测试函数。
- `views.py`：处理用户HTTP请求并返回HTTP响应的函数或类（MTV中的V）。

### 模型

模型准确且唯一的描述了数据。它包含您储存的数据的重要字段和行为。一般来说，每一个模型都映射一张数据库表。

```python
from django.db import models


class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
```

上面的 `Person` 模型会创建一个如下的数据库表：

```python
CREATE TABLE myapp_person (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(30) NOT NULL
);
```

一些技术上的说明：

- 该表的名称 `myapp_person` 是自动从某些模型元数据中派生出来，但可以被改写。参阅 [表名称](https://docs.djangoproject.com/zh-hans/5.2/ref/models/options/#table-names) 获取更多信息。
- 一个 `id` 字段会被自动添加，但是这种行为可以被改写。请参阅 [自动设置主键](https://docs.djangoproject.com/zh-hans/5.2/topics/db/models/#automatic-primary-key-fields)。

#### 使用模型

一旦你定义了你的模型，你需要告诉 Django 你准备 *使用* 这些模型。你需要修改设置文件中的 [`INSTALLED_APPS`](https://docs.djangoproject.com/zh-hans/5.2/ref/settings/#std-setting-INSTALLED_APPS) ，在这个设置中添加包含 `models.py` 文件的模块名称。

例如，若模型位于项目中的 `myapp.models` 模块（ 此包结构由 [`manage.py startapp`](https://docs.djangoproject.com/zh-hans/5.2/ref/django-admin/#django-admin-startapp) 命令创建）， [`INSTALLED_APPS`](https://docs.djangoproject.com/zh-hans/5.2/ref/settings/#std-setting-INSTALLED_APPS) 应设置如下：

```python
INSTALLED_APPS = [
    # ...
    "myapp",
    # ...
]
```

#### 字段类型

模型中每一个字段都应该是某个 [`Field`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field) 类的实例， Django 利用这些字段类来实现以下功能：

你可以在 [模型字段参考](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#model-field-types) 中看到完整列表

##### 常用的字段列表

######  `AutoField`

一个 [`IntegerField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.IntegerField)，根据可用的 ID 自动递增。你通常不需要直接使用它；如果你没有指定，主键字段会自动添加到你的模型中。

###### `BooleanField`

一个 true／false 字段。

###### `CharField`

一个字符串字段，适用于小到大的字符串。

对于大量的文本，使用 [`TextField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.TextField)。

[`CharField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.CharField) 具有以下额外参数：CharField.max_length

###### `DateField`

- DateField.auto_now

  每次保存对象时，自动将该字段设置为现在。对于“最后修改”的时间戳很有用。请注意，当前日期 *总是* 被使用，而不仅仅是一个你可以覆盖的默认值。只有在调用 [`Model.save()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/instances/#django.db.models.Model.save) 时，该字段才会自动更新。当以其他方式对其他字段进行更新时，如 [`QuerySet.update()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet.update)，该字段不会被更新，尽管你可以在这样的更新中为该字段指定一个自定义值。

- DateField.auto_now_add

  当第一次创建对象时，自动将该字段设置为现在。对创建时间戳很有用。请注意，当前日期是 *始终* 使用的；它不是一个你可以覆盖的默认值。因此，即使你在创建对象时为该字段设置了一个值，它也会被忽略。

###### `DateTimeField`

一个日期和时间，在 Python 中用一个 `datetime.datetime` 实例表示。与 [`DateField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.DateField) 一样，使用相同的额外参数。

###### `EmailField`

一个 [`CharField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.CharField)，使用 [`EmailValidator`](https://docs.djangoproject.com/zh-hans/5.2/ref/validators/#django.core.validators.EmailValidator) 来检查该值是否为有效的电子邮件地址。

###### `FloatField`

在 Python 中用一个 `float` 实例表示的浮点数。

###### `IntegerField`

一个整数。其值仅允许在特定范围内（取决于数据库）。在Django支持的所有数据库中，-2147483648到2147483647之间的值都是兼容的

###### `JSONField`

一个用于存储 JSON 编码数据的字段。

###### `TextField`

一个大的文本字段。

###### `TimeField`

一个时间，

###### `URLField`

该字段的默认表单部件是一个 [`URLInput`](https://docs.djangoproject.com/zh-hans/5.2/ref/forms/widgets/#django.forms.URLInput)。

###### `UUIDField`

通用唯一标识符是 [`primary_key`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.primary_key) 的 [`AutoField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.AutoField) 的一个很好的替代方案。数据库不会为你生成 UUID，所以建议使用 [`default`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.default) ：

```python
import uuid
from django.db import models


class MyUUIDModel(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    # other fields
```

##### 关系字段

###### ForeignKey

多对一关系。需要两个位置参数：模型关联的类和 [`on_delete`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ForeignKey.on_delete) 选项：

```python
from django.db import models


class Manufacturer(models.Model):
    name = models.TextField()


class Car(models.Model):
    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)
```

第一个位置参数可以是具体模型类或对模型类的 [延迟引用](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#lazy-relationships)。还支持 [递归关系](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#recursive-relationships)，即模型与自身的关系。

第二个位置参数级联删除。Django模拟了SQL约束ON DELETE CASCADE的行为，并且还会删除包含ForeignKey的对象。

###### `ManyToManyField`

一个多对多的关系。需要一个位置参数：模型相关的类，它的工作原理与 [`ForeignKey`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ForeignKey) 完全相同，包括 [递归](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#recursive-relationships) 和 [惰性](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#lazy-relationships) 关系。

###### `OneToOneField`

一对一的关系。

#### 字段选项

下面介绍一部分经常用到的通用参数：

##### [`null`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.null)

如果设置为 `True`，当该字段为空时，Django 会将数据库中该字段设置为 `NULL`。默认为 `False` 。

##### [`blank`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.blank)

如果设置为 `True`，该字段允许为空。默认为 `False`。

请注意，这与 [`null`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.null) 不同。[`null`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.null) 完全与数据库相关联，而 [`blank`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.blank) 与验证有关。如果字段具有 [`blank=True`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.blank)，表单验证将允许输入空值。如果字段具有 [`blank=False`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.blank)，则字段为必填项。

##### [`choices`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.choices)

一个由二元组组成的序列、映射、枚举类型或可调用对象（无需参数并返回上述任意格式），用作该字段的选项。如果提供了此参数，默认的表单控件将变为选择框而非标准文本框，并将选项限制为给定的选项

```python
YEAR_IN_SCHOOL_CHOICES = [
    ("FR", "Freshman"),
    ("SO", "Sophomore"),
    ("JR", "Junior"),
    ("SR", "Senior"),
    ("GR", "Graduate"),
]
```

每个二元组的第一个值会储存在数据库中，而第二个值将只会用于在表单中显示。

对于一个模型实例，要获取该字段二元组中相对应的第二个值，使用 [`get_FOO_display()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/instances/#django.db.models.Model.get_FOO_display) 方法。例如：

```python
from django.db import models


class Person(models.Model):
    SHIRT_SIZES = {
        "S": "Small",
        "M": "Medium",
        "L": "Large",
    }
    name = models.CharField(max_length=60)
    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)
```

```python
>>> p = Person(name="Fred Flintstone", shirt_size="L")
>>> p.save()
>>> p.shirt_size
'L'
>>> p.get_shirt_size_display()
'Large'
```

##### [`default`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.default)

该字段的默认值。可以是一个值或者是个可调用的对象，如果是个可调用对象，每次实例化模型时都会调用该对象。

##### [`primary_key`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.primary_key)

如果设置为 `True` ，将该字段设置为该模型的主键

##### [`unique`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.unique)

如果设置为 `True`，这个字段的值必须在整个表中保持唯一。

#### 字段备注名

除了 [`ForeignKey`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ForeignKey)， [`ManyToManyField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ManyToManyField) 和 [`OneToOneField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.OneToOneField)，任何字段类型都接收一个可选的位置参数 [`verbose_name`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.verbose_name)，如果未指定该参数值， Django 会自动使用字段的属性名作为该参数值，并且把下划线转换为空格。

```python
first_name = models.CharField("person's first name", max_length=30)
```

#### 关联关系

## Django

### 项目文件说明

- `项目名/__init__.py`：空文件，告诉Python解释器这个目录应该被视为一个Python的包。
- `项目名/settings.py`：Django项目的配置文件。
- `项目名/urls.py`：Django项目的URL映射声明，就像是网站的“目录”。
- `项目名/wsgi.py`：项目运行在WSGI兼容Web服务器上的入口文件。
- `manage.py`： 管理Django项目的脚本程序。

### 修改项目的配置文件`settings.py`。

Django是一个支持国际化和本地化的框架，因此刚才我们看到的Django项目的默认首页也是支持国际化的，我们可以通过修改配置文件将默认语言修改为中文，时区设置为东八区。

```python
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
```

修改为以下内容。

```python
LANGUAGE_CODE = "zh-hans"
TIME_ZONE = "Asia/Shanghai"
```

### 创建自己的应用

如果要开发自己的Web应用，需要先在Django项目中创建“应用”，一个Django项目可以包含一个或多个应用。

1. 在PyCharm的终端中执行下面的命令，创建名为`first`的应用。

```bash
python manage.py startapp first
```

执行上面的命令会在当前路径下创建`first`目录，其目录结构如下所示：

- `__init__.py`：一个空文件，告诉Python解释器这个目录应该被视为一个Python的包。
- `admin.py`：可以用来注册模型，用于在Django框架自带的管理后台中管理模型。
- `apps.py`：当前应用的配置文件。
- migrations：存放与模型有关的数据库迁移信息。
  - `__init__.py`：一个空文件，告诉Python解释器这个目录应该被视为一个Python的包。

- `models.py`：存放应用的数据模型（MTV中的M）。
- `tests.py`：包含测试应用各项功能的测试类和测试函数。
- `views.py`：处理用户HTTP请求并返回HTTP响应的函数或类（MTV中的V）。

### 模型

模型准确且唯一的描述了数据。它包含您储存的数据的重要字段和行为。一般来说，每一个模型都映射一张数据库表。

```python
from django.db import models


class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
```

上面的 `Person` 模型会创建一个如下的数据库表：

```python
CREATE TABLE myapp_person (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(30) NOT NULL
);
```

一些技术上的说明：

- 该表的名称 `myapp_person` 是自动从某些模型元数据中派生出来，但可以被改写。参阅 [表名称](https://docs.djangoproject.com/zh-hans/5.2/ref/models/options/#table-names) 获取更多信息。
- 一个 `id` 字段会被自动添加，但是这种行为可以被改写。请参阅 [自动设置主键](https://docs.djangoproject.com/zh-hans/5.2/topics/db/models/#automatic-primary-key-fields)。

#### 使用模型

一旦你定义了你的模型，你需要告诉 Django 你准备 *使用* 这些模型。你需要修改设置文件中的 [`INSTALLED_APPS`](https://docs.djangoproject.com/zh-hans/5.2/ref/settings/#std-setting-INSTALLED_APPS) ，在这个设置中添加包含 `models.py` 文件的模块名称。

例如，若模型位于项目中的 `myapp.models` 模块（ 此包结构由 [`manage.py startapp`](https://docs.djangoproject.com/zh-hans/5.2/ref/django-admin/#django-admin-startapp) 命令创建）， [`INSTALLED_APPS`](https://docs.djangoproject.com/zh-hans/5.2/ref/settings/#std-setting-INSTALLED_APPS) 应设置如下：

```python
INSTALLED_APPS = [
    # ...
    "myapp",
    # ...
]
```

#### 字段类型

模型中每一个字段都应该是某个 [`Field`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field) 类的实例， Django 利用这些字段类来实现以下功能：

你可以在 [模型字段参考](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#model-field-types) 中看到完整列表

##### 常用的字段列表

######  `AutoField`

一个 [`IntegerField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.IntegerField)，根据可用的 ID 自动递增。你通常不需要直接使用它；如果你没有指定，主键字段会自动添加到你的模型中。

###### `BooleanField`

一个 true／false 字段。

###### `CharField`

一个字符串字段，适用于小到大的字符串。

对于大量的文本，使用 [`TextField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.TextField)。

[`CharField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.CharField) 具有以下额外参数：CharField.max_length

###### `DateField`

- DateField.auto_now

  每次保存对象时，自动将该字段设置为现在。对于“最后修改”的时间戳很有用。请注意，当前日期 *总是* 被使用，而不仅仅是一个你可以覆盖的默认值。只有在调用 [`Model.save()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/instances/#django.db.models.Model.save) 时，该字段才会自动更新。当以其他方式对其他字段进行更新时，如 [`QuerySet.update()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet.update)，该字段不会被更新，尽管你可以在这样的更新中为该字段指定一个自定义值。

- DateField.auto_now_add

  当第一次创建对象时，自动将该字段设置为现在。对创建时间戳很有用。请注意，当前日期是 *始终* 使用的；它不是一个你可以覆盖的默认值。因此，即使你在创建对象时为该字段设置了一个值，它也会被忽略。

###### `DateTimeField`

一个日期和时间，在 Python 中用一个 `datetime.datetime` 实例表示。与 [`DateField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.DateField) 一样，使用相同的额外参数。

###### `EmailField`

一个 [`CharField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.CharField)，使用 [`EmailValidator`](https://docs.djangoproject.com/zh-hans/5.2/ref/validators/#django.core.validators.EmailValidator) 来检查该值是否为有效的电子邮件地址。

###### `FloatField`

在 Python 中用一个 `float` 实例表示的浮点数。

###### `IntegerField`

一个整数。其值仅允许在特定范围内（取决于数据库）。在Django支持的所有数据库中，-2147483648到2147483647之间的值都是兼容的

###### `JSONField`

一个用于存储 JSON 编码数据的字段。

###### `TextField`

一个大的文本字段。

###### `TimeField`

一个时间，

###### `URLField`

该字段的默认表单部件是一个 [`URLInput`](https://docs.djangoproject.com/zh-hans/5.2/ref/forms/widgets/#django.forms.URLInput)。

###### `UUIDField`

通用唯一标识符是 [`primary_key`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.primary_key) 的 [`AutoField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.AutoField) 的一个很好的替代方案。数据库不会为你生成 UUID，所以建议使用 [`default`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.default) ：

```python
import uuid
from django.db import models


class MyUUIDModel(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    # other fields
```

##### 关系字段

###### ForeignKey

多对一关系。需要两个位置参数：模型关联的类和 [`on_delete`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ForeignKey.on_delete) 选项：

```python
from django.db import models


class Manufacturer(models.Model):
    name = models.TextField()


class Car(models.Model):
    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)
```

第一个位置参数可以是具体模型类或对模型类的 [延迟引用](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#lazy-relationships)。还支持 [递归关系](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#recursive-relationships)，即模型与自身的关系。

第二个位置参数级联删除。Django模拟了SQL约束ON DELETE CASCADE的行为，并且还会删除包含ForeignKey的对象。

###### `ManyToManyField`

一个多对多的关系。需要一个位置参数：模型相关的类，它的工作原理与 [`ForeignKey`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ForeignKey) 完全相同，包括 [递归](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#recursive-relationships) 和 [惰性](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#lazy-relationships) 关系。

###### `OneToOneField`

一对一的关系。

#### 字段选项

下面介绍一部分经常用到的通用参数：

##### [`null`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.null)

如果设置为 `True`，当该字段为空时，Django 会将数据库中该字段设置为 `NULL`。默认为 `False` 。

##### [`blank`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.blank)

如果设置为 `True`，该字段允许为空。默认为 `False`。

请注意，这与 [`null`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.null) 不同。[`null`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.null) 完全与数据库相关联，而 [`blank`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.blank) 与验证有关。如果字段具有 [`blank=True`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.blank)，表单验证将允许输入空值。如果字段具有 [`blank=False`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.blank)，则字段为必填项。

##### [`choices`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.choices)

一个由二元组组成的序列、映射、枚举类型或可调用对象（无需参数并返回上述任意格式），用作该字段的选项。如果提供了此参数，默认的表单控件将变为选择框而非标准文本框，并将选项限制为给定的选项

```python
YEAR_IN_SCHOOL_CHOICES = [
    ("FR", "Freshman"),
    ("SO", "Sophomore"),
    ("JR", "Junior"),
    ("SR", "Senior"),
    ("GR", "Graduate"),
]
```

每个二元组的第一个值会储存在数据库中，而第二个值将只会用于在表单中显示。

对于一个模型实例，要获取该字段二元组中相对应的第二个值，使用 [`get_FOO_display()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/instances/#django.db.models.Model.get_FOO_display) 方法。例如：

```python
from django.db import models


class Person(models.Model):
    SHIRT_SIZES = {
        "S": "Small",
        "M": "Medium",
        "L": "Large",
    }
    name = models.CharField(max_length=60)
    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)
```

```python
>>> p = Person(name="Fred Flintstone", shirt_size="L")
>>> p.save()
>>> p.shirt_size
'L'
>>> p.get_shirt_size_display()
'Large'
```

##### [`default`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.default)

该字段的默认值。可以是一个值或者是个可调用的对象，如果是个可调用对象，每次实例化模型时都会调用该对象。

##### [`primary_key`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.primary_key)

如果设置为 `True` ，将该字段设置为该模型的主键

##### [`unique`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.unique)

如果设置为 `True`，这个字段的值必须在整个表中保持唯一。

#### 字段备注名

除了 [`ForeignKey`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ForeignKey)， [`ManyToManyField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ManyToManyField) 和 [`OneToOneField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.OneToOneField)，任何字段类型都接收一个可选的位置参数 [`verbose_name`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.verbose_name)，如果未指定该参数值， Django 会自动使用字段的属性名作为该参数值，并且把下划线转换为空格。

```python
first_name = models.CharField("person's first name", max_length=30)
```

#### 关联关系

## Django

### 项目文件说明

- `项目名/__init__.py`：空文件，告诉Python解释器这个目录应该被视为一个Python的包。
- `项目名/settings.py`：Django项目的配置文件。
- `项目名/urls.py`：Django项目的URL映射声明，就像是网站的“目录”。
- `项目名/wsgi.py`：项目运行在WSGI兼容Web服务器上的入口文件。
- `manage.py`： 管理Django项目的脚本程序。

### 修改项目的配置文件`settings.py`。

Django是一个支持国际化和本地化的框架，因此刚才我们看到的Django项目的默认首页也是支持国际化的，我们可以通过修改配置文件将默认语言修改为中文，时区设置为东八区。

```python
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
```

修改为以下内容。

```python
LANGUAGE_CODE = "zh-hans"
TIME_ZONE = "Asia/Shanghai"
```

### 创建自己的应用

如果要开发自己的Web应用，需要先在Django项目中创建“应用”，一个Django项目可以包含一个或多个应用。

1. 在PyCharm的终端中执行下面的命令，创建名为`first`的应用。

```bash
python manage.py startapp first
```

执行上面的命令会在当前路径下创建`first`目录，其目录结构如下所示：

- `__init__.py`：一个空文件，告诉Python解释器这个目录应该被视为一个Python的包。
- `admin.py`：可以用来注册模型，用于在Django框架自带的管理后台中管理模型。
- `apps.py`：当前应用的配置文件。
- migrations：存放与模型有关的数据库迁移信息。
  - `__init__.py`：一个空文件，告诉Python解释器这个目录应该被视为一个Python的包。

- `models.py`：存放应用的数据模型（MTV中的M）。
- `tests.py`：包含测试应用各项功能的测试类和测试函数。
- `views.py`：处理用户HTTP请求并返回HTTP响应的函数或类（MTV中的V）。

### 模型

模型准确且唯一的描述了数据。它包含您储存的数据的重要字段和行为。一般来说，每一个模型都映射一张数据库表。

```python
from django.db import models


class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
```

上面的 `Person` 模型会创建一个如下的数据库表：

```python
CREATE TABLE myapp_person (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(30) NOT NULL
);
```

一些技术上的说明：

- 该表的名称 `myapp_person` 是自动从某些模型元数据中派生出来，但可以被改写。参阅 [表名称](https://docs.djangoproject.com/zh-hans/5.2/ref/models/options/#table-names) 获取更多信息。
- 一个 `id` 字段会被自动添加，但是这种行为可以被改写。请参阅 [自动设置主键](https://docs.djangoproject.com/zh-hans/5.2/topics/db/models/#automatic-primary-key-fields)。

#### 使用模型

一旦你定义了你的模型，你需要告诉 Django 你准备 *使用* 这些模型。你需要修改设置文件中的 [`INSTALLED_APPS`](https://docs.djangoproject.com/zh-hans/5.2/ref/settings/#std-setting-INSTALLED_APPS) ，在这个设置中添加包含 `models.py` 文件的模块名称。

例如，若模型位于项目中的 `myapp.models` 模块（ 此包结构由 [`manage.py startapp`](https://docs.djangoproject.com/zh-hans/5.2/ref/django-admin/#django-admin-startapp) 命令创建）， [`INSTALLED_APPS`](https://docs.djangoproject.com/zh-hans/5.2/ref/settings/#std-setting-INSTALLED_APPS) 应设置如下：

```python
INSTALLED_APPS = [
    # ...
    "myapp",
    # ...
]
```

#### 字段类型

模型中每一个字段都应该是某个 [`Field`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field) 类的实例， Django 利用这些字段类来实现以下功能：

你可以在 [模型字段参考](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#model-field-types) 中看到完整列表

##### 常用的字段列表

######  `AutoField`

一个 [`IntegerField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.IntegerField)，根据可用的 ID 自动递增。你通常不需要直接使用它；如果你没有指定，主键字段会自动添加到你的模型中。

###### `BooleanField`

一个 true／false 字段。

###### `CharField`

一个字符串字段，适用于小到大的字符串。

对于大量的文本，使用 [`TextField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.TextField)。

[`CharField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.CharField) 具有以下额外参数：CharField.max_length

###### `DateField`

- DateField.auto_now

  每次保存对象时，自动将该字段设置为现在。对于“最后修改”的时间戳很有用。请注意，当前日期 *总是* 被使用，而不仅仅是一个你可以覆盖的默认值。只有在调用 [`Model.save()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/instances/#django.db.models.Model.save) 时，该字段才会自动更新。当以其他方式对其他字段进行更新时，如 [`QuerySet.update()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet.update)，该字段不会被更新，尽管你可以在这样的更新中为该字段指定一个自定义值。

- DateField.auto_now_add

  当第一次创建对象时，自动将该字段设置为现在。对创建时间戳很有用。请注意，当前日期是 *始终* 使用的；它不是一个你可以覆盖的默认值。因此，即使你在创建对象时为该字段设置了一个值，它也会被忽略。

###### `DateTimeField`

一个日期和时间，在 Python 中用一个 `datetime.datetime` 实例表示。与 [`DateField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.DateField) 一样，使用相同的额外参数。

###### `EmailField`

一个 [`CharField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.CharField)，使用 [`EmailValidator`](https://docs.djangoproject.com/zh-hans/5.2/ref/validators/#django.core.validators.EmailValidator) 来检查该值是否为有效的电子邮件地址。

###### `FloatField`

在 Python 中用一个 `float` 实例表示的浮点数。

###### `IntegerField`

一个整数。其值仅允许在特定范围内（取决于数据库）。在Django支持的所有数据库中，-2147483648到2147483647之间的值都是兼容的

###### `JSONField`

一个用于存储 JSON 编码数据的字段。

###### `TextField`

一个大的文本字段。

###### `TimeField`

一个时间，

###### `URLField`

该字段的默认表单部件是一个 [`URLInput`](https://docs.djangoproject.com/zh-hans/5.2/ref/forms/widgets/#django.forms.URLInput)。

###### `UUIDField`

通用唯一标识符是 [`primary_key`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.primary_key) 的 [`AutoField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.AutoField) 的一个很好的替代方案。数据库不会为你生成 UUID，所以建议使用 [`default`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.default) ：

```python
import uuid
from django.db import models


class MyUUIDModel(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    # other fields
```

##### 关系字段

###### ForeignKey

多对一关系。需要两个位置参数：模型关联的类和 [`on_delete`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ForeignKey.on_delete) 选项：

```python
from django.db import models


class Manufacturer(models.Model):
    name = models.TextField()


class Car(models.Model):
    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)
```

第一个位置参数可以是具体模型类或对模型类的 [延迟引用](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#lazy-relationships)。还支持 [递归关系](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#recursive-relationships)，即模型与自身的关系。

第二个位置参数级联删除。Django模拟了SQL约束ON DELETE CASCADE的行为，并且还会删除包含ForeignKey的对象。

###### `ManyToManyField`

一个多对多的关系。需要一个位置参数：模型相关的类，它的工作原理与 [`ForeignKey`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ForeignKey) 完全相同，包括 [递归](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#recursive-relationships) 和 [惰性](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#lazy-relationships) 关系。

###### `OneToOneField`

一对一的关系。

#### 字段选项

下面介绍一部分经常用到的通用参数：

##### [`null`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.null)

如果设置为 `True`，当该字段为空时，Django 会将数据库中该字段设置为 `NULL`。默认为 `False` 。

##### [`blank`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.blank)

如果设置为 `True`，该字段允许为空。默认为 `False`。

请注意，这与 [`null`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.null) 不同。[`null`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.null) 完全与数据库相关联，而 [`blank`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.blank) 与验证有关。如果字段具有 [`blank=True`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.blank)，表单验证将允许输入空值。如果字段具有 [`blank=False`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.blank)，则字段为必填项。

##### [`choices`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.choices)

一个由二元组组成的序列、映射、枚举类型或可调用对象（无需参数并返回上述任意格式），用作该字段的选项。如果提供了此参数，默认的表单控件将变为选择框而非标准文本框，并将选项限制为给定的选项

```python
YEAR_IN_SCHOOL_CHOICES = [
    ("FR", "Freshman"),
    ("SO", "Sophomore"),
    ("JR", "Junior"),
    ("SR", "Senior"),
    ("GR", "Graduate"),
]
```

每个二元组的第一个值会储存在数据库中，而第二个值将只会用于在表单中显示。

对于一个模型实例，要获取该字段二元组中相对应的第二个值，使用 [`get_FOO_display()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/instances/#django.db.models.Model.get_FOO_display) 方法。例如：

```python
from django.db import models


class Person(models.Model):
    SHIRT_SIZES = {
        "S": "Small",
        "M": "Medium",
        "L": "Large",
    }
    name = models.CharField(max_length=60)
    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)
```

```python
>>> p = Person(name="Fred Flintstone", shirt_size="L")
>>> p.save()
>>> p.shirt_size
'L'
>>> p.get_shirt_size_display()
'Large'
```

##### [`default`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.default)

该字段的默认值。可以是一个值或者是个可调用的对象，如果是个可调用对象，每次实例化模型时都会调用该对象。

##### [`primary_key`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.primary_key)

如果设置为 `True` ，将该字段设置为该模型的主键

##### [`unique`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.unique)

如果设置为 `True`，这个字段的值必须在整个表中保持唯一。

#### 字段备注名

除了 [`ForeignKey`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ForeignKey)， [`ManyToManyField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ManyToManyField) 和 [`OneToOneField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.OneToOneField)，任何字段类型都接收一个可选的位置参数 [`verbose_name`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field.verbose_name)，如果未指定该参数值， Django 会自动使用字段的属性名作为该参数值，并且把下划线转换为空格。

```python
first_name = models.CharField("person's first name", max_length=30)
```

#### 关联关系

显然，关系型数据库的强大之处在于各表之间的关联关系。 Django 提供了定义三种最常见的数据库关联关系的方法：多对一，多对多，一对一。

##### 多对一关联

定义一个多对一的关联关系，使用 [`django.db.models.ForeignKey`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ForeignKey) 类。就和其它 [`Field`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.Field) 字段类型一样，只需要在你模型中添加一个值为该类的属性。

[`ForeignKey`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ForeignKey) 类需要添加一个位置参数，即你想要关联的模型类名。

例如，如果一个 `Car` 模型有一个制造者 `Manufacturer` --就是说一个 `Manufacturer` 制造许多辆车，但是每辆车都仅有一个制造者-- 那么使用下面的方法定义这个关系：

```python
from django.db import models


class Manufacturer(models.Model):
    # ...
    pass


class Car(models.Model):
    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)
    # ...
```

##### 多对多关联

例如：如果 `Pizza` 含有多种 `Topping` （配料） -- 也就是一种 `Topping` 可能存在于多个 `Pizza` 中，并且每个 `Pizza` 含有多种 `Topping` --那么可以这样表示这种关系：

```python
from django.db import models


class Topping(models.Model):
    # ...
    pass


class Pizza(models.Model):
    # ...
    toppings = models.ManyToManyField(Topping)

```

建议设置 [`ManyToManyField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ManyToManyField) 字段名（上例中的 `toppings` ）为一个复数名词，表示所要关联的模型对象的集合。

对于多对多关联关系的两个模型，可以在任何一个模型中添加 [`ManyToManyField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ManyToManyField) 字段，但只能选择一个模型设置该字段，即不能同时在两模型中添加该字段。

一般来讲，应该把 [`ManyToManyField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ManyToManyField) 实例放到需要在表单中被编辑的对象中。在之前的例子中， `toppings` 被放在 `Pizza` 当中（而不是 `Topping` 中有指向 `pizzas` 的 [`ManyToManyField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ManyToManyField) 实例 ）因为相较于配料被放在不同的披萨当中，披萨当中有很多种配料更加符合常理。按照先前说的，在编辑 `Pizza` 的表单时用户可以选择多种配料。

###### 在多对多(many-to-many)关系中添加添加额外的属性字段

举例来讲，考虑一个需要跟踪音乐人属于哪个音乐组的应用程序。在人和他们所在的组之间有一个多对多关系，你可以使用 [`ManyToManyField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ManyToManyField) 来代表这个关系。然而，你想要记录更多的信息在这样的关联关系当中，比如你想要记录某人是何时加入一个组的。

对于这些情况，Django 允许你指定用于控制多对多关系的模型。你可以在中间模型当中添加额外的字段。在实例化 [`ManyToManyField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ManyToManyField) 的时候使用 [`through`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ManyToManyField.through) 参数指定多对多关系使用哪个中间模型。对于我们举的音乐家的例子，代码如下：

```python
from django.db import models


class Person(models.Model):
    name = models.CharField(max_length=128)

    def __str__(self):
        return self.name


class Group(models.Model):
    name = models.CharField(max_length=128)
    members = models.ManyToManyField(Person, through="Membership")

    def __str__(self):
        return self.name


class Membership(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE)
    group = models.ForeignKey(Group, on_delete=models.CASCADE)
    date_joined = models.DateField()
    invite_reason = models.CharField(max_length=64)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["person", "group"], name="unique_person_group"
            )
        ]
```

##### 一对一关联

使用 [`OneToOneField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.OneToOneField) 来定义一对一关系。就像使用其他类型的 `Field` 一样：在模型属性中包含它。

#### `Meta` 选项

使用内部 `Meta类` 来给模型赋予元数据，就像：

```python
from django.db import models


class Ox(models.Model):
    horn_length = models.IntegerField()

    class Meta:
        ordering = ["horn_length"]
        verbose_name_plural = "oxen"

```

模型的元数据即“所有不是字段的东西”，比如排序选项（ [`ordering`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/options/#django.db.models.Options.ordering) ），数据库表名（ [`db_table`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/options/#django.db.models.Options.db_table) ），或是阅读友好的单复数名（ [`verbose_name`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/options/#django.db.models.Options.verbose_name) 和 [`verbose_name_plural`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/options/#django.db.models.Options.verbose_name_plural) ）。这些都不是必须的，并且在模型当中添加 `Meta类` 也完全是可选的

在 [模型可选参数参考](https://docs.djangoproject.com/zh-hans/5.2/ref/models/options/) 中列出了 `Meta` 可使用的全部选项。

#### 模型属性

模型当中最重要的属性是 [`Manager`](https://docs.djangoproject.com/zh-hans/5.2/topics/db/managers/#django.db.models.Manager)。它是 Django 模型和数据库查询操作之间的接口，并且它被用作从数据库当中 [获取实例](https://docs.djangoproject.com/zh-hans/5.2/topics/db/queries/#retrieving-objects)，如果没有指定自定义的 `Manager` 默认名称是 [`objects`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/class/#django.db.models.Model.objects)。Manager 只能通过模型类来访问，不能通过模型实例来访问。

在模型中添加自定义方法会给你的对象提供自定义的“行级”操作能力。与之对应的是类 [`Manager`](https://docs.djangoproject.com/zh-hans/5.2/topics/db/managers/#django.db.models.Manager) 的方法意在提供“表级”的操作，模型方法应该在某个对象实例上生效。

### 数据库操作

一旦创建 [数据模型](https://docs.djangoproject.com/zh-hans/5.2/topics/db/models/) 后，Django 自动给予你一套数据库抽象 API，允许你创建，检索，更新和删除对象。

#### 将修改保存至对象

```python
>>> from blog.models import Blog, Entry
>>> entry = Entry.objects.get(pk=1)
>>> cheese_blog = Blog.objects.get(name="Cheddar Talk")
>>> entry.blog = cheese_blog
>>> entry.save()
```

更新 [`ManyToManyField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ManyToManyField) 有一些不同之处——可以使用字段上的 [`add()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/relations/#django.db.models.fields.related.RelatedManager.add) 方法来添加一个记录到关系中。这个示例将 `Author` 实例 `joe` 添加到 `entry` 对象中：

```python
>>> from blog.models import Author
>>> joe = Author.objects.create(name="Joe")
>>> entry.authors.add(joe)
```

要一次性添加多个记录到 [`ManyToManyField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ManyToManyField)，在调用 [`add()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/relations/#django.db.models.fields.related.RelatedManager.add) 时包括多个参数，如下所示：

```python
>>> john = Author.objects.create(name="John")
>>> paul = Author.objects.create(name="Paul")
>>> george = Author.objects.create(name="George")
>>> ringo = Author.objects.create(name="Ringo")
>>> entry.authors.add(john, paul, george, ringo)
```

#### 检索对象

要从数据库检索对象，要通过模型类的 [`Manager`](https://docs.djangoproject.com/zh-hans/5.2/topics/db/managers/#django.db.models.Manager) 构建一个 [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet)。

一个 [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet) 代表来自数据库中对象的一个集合。它可以有 0 个，1 个或者多个 *filters*. Filters，可以根据给定参数缩小查询结果量。在 SQL 的层面上， [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet) 对应 `SELECT` 语句，而*filters*对应类似 `WHERE` 或 `LIMIT` 的限制子句。

通过使用你的模型的 [`Manager`](https://docs.djangoproject.com/zh-hans/5.2/topics/db/managers/#django.db.models.Manager)，你可以获得一个 [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet)。每个模型至少有一个 [`Manager`](https://docs.djangoproject.com/zh-hans/5.2/topics/db/managers/#django.db.models.Manager)，默认情况下称为 [`objects`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/class/#django.db.models.Model.objects)。可以直接通过模型类来访问它，如下所示：

```python
>>> Blog.objects
<django.db.models.manager.Manager object at ...>
>>> b = Blog(name="Foo", tagline="Bar")
>>> b.objects
Traceback:
    ...
AttributeError: "Manager isn't accessible via Blog instances."
```

##### 检索全部对象

从表中检索对象的最简单方法是获取所有对象。要做到这一点，可以在 [`Manager`](https://docs.djangoproject.com/zh-hans/5.2/topics/db/managers/#django.db.models.Manager) 上使用 [`all()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet.all) 方法：

```python
>>> all_entries = Entry.objects.all()
```

##### 通过过滤器检索指定对象

- `filter(**kwargs)`

  返回一个新的 [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet)，包含的对象满足给定查询参数。

- `exclude(**kwargs)`

  返回一个新的 [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet)，包含的对象 *不* 满足给定查询参数。

查询参数（`**kwargs`）应该符合下面的 [Field lookups](https://docs.djangoproject.com/zh-hans/5.2/topics/db/queries/#field-lookups) 的要求。

例如，要包含获取 2006 年的博客条目（entries blog）的 [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet)，像这样使用 [`filter()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet.filter):

```python
Entry.objects.filter(pub_date__year=2006)
```

通过默认管理器类也一样:

```python
Entry.objects.all().filter(pub_date__year=2006)
```

##### 链式过滤器

对 [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet) 进行细化的结果本身也是一个 [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet)，因此可以将细化操作链接在一起。例如：

```python
>>> Entry.objects.filter(headline__startswith="What").exclude(
...     pub_date__gte=datetime.date.today()
... ).filter(pub_date__gte=datetime.date(2005, 1, 30))

```

这个先获取包含数据库所有条目（entry）的 [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet)，然后排除一些，再进入另一个过滤器。最终的 [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet) 包含标题以 "What" 开头的，发布日期介于 2005 年 1 月 30 日与今天之间的所有条目。

##### 每个 `QuerySet` 都是唯一的

每次你细化一个 [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet)，都会得到一个新的、完全不受之前 [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet) 影响的 [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet)。每一次细化都创建了一个独立且不同的 [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet)，它可以被存储、使用和重复利用。

```python
>>> q1 = Entry.objects.filter(headline__startswith="What")
>>> q2 = q1.exclude(pub_date__gte=datetime.date.today())
>>> q3 = q1.filter(pub_date__gte=datetime.date.today())
```

##### `QuerySet` 是惰性的[¶](https://docs.djangoproject.com/zh-hans/5.2/topics/db/queries/#querysets-are-lazy)

QuerySet对象是惰性的——创建QuerySet并不会立即执行任何数据库操作。你可以整天叠加各种过滤器，但Django实际上要等到QuerySet被求值时才会运行查询。看看这个例子

```python
>>> q = Entry.objects.filter(headline__startswith="What")
>>> q = q.filter(pub_date__lte=datetime.date.today())
>>> q = q.exclude(body_text__icontains="food")
>>> print(q)
```

虽然这看起来像是三次数据库操作，实际上只在最后一行 (`print(q)`) 做了一次。一般来说， [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet) 的结果直到你 “要使用” 时才会从数据库中拿出。当你要用时，才通过数据库 *计算* 出 [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet)。关于何时才真的执行计算的更多细节，参考 [什么时候 QuerySet 被执行](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#when-querysets-are-evaluated)。

##### 用 `get()` 检索单个对象[¶](https://docs.djangoproject.com/zh-hans/5.2/topics/db/queries/#retrieving-a-single-object-with-get)

[`filter()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet.filter) 总是返回一个 [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet)，即便只有一个对象满足查询条件 —— 这种情况下， [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet) 只包含了一个元素。

如果你知道只有一个对象符合你的查询条件，你可以在 [`Manager`](https://docs.djangoproject.com/zh-hans/5.2/topics/db/managers/#django.db.models.Manager) 上使用 [`get()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet.get) 方法，它会直接返回该对象

```python
>>> one_entry = Entry.objects.get(pk=1)
```

你可以对 [`get()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet.get) 使用与 [`filter()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet.filter) 类似的所有查询表达式 —— 同样的，参考下面的 [Field lookups](https://docs.djangoproject.com/zh-hans/5.2/topics/db/queries/#field-lookups)。

##### 其它 `QuerySet` 方法

###### 限制 `QuerySet` 条目数

利用 Python 的数组切片语法将 [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet) 切成指定长度。这等价于 SQL 的 `LIMIT` 和 `OFFSET` 子句。

例如，这返回前5个对象（`LIMIT 5`）

```python
>>> Entry.objects.all()[:5]
```

这返回第六到第十个对象（`OFFSET 5 LIMIT 5`）：

```python
>>> Entry.objects.all()[5:10]
```

###### 字段查询

字段查询即你如何制定 SQL `WHERE` 子句。它们以关键字参数的形式传递给 [`QuerySet`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet) 方法 [`filter()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet.filter)， [`exclude()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet.exclude) 和 [`get()`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#django.db.models.query.QuerySet.get)。

基本的查找关键字参数采用形式 `field__lookuptype=value` （使用双下划线）。例如：

```python
>>> Entry.objects.filter(pub_date__lte="2006-01-01")
```

转换为 SQL 语句大致如下：

```python
SELECT * FROM blog_entry WHERE pub_date <= '2006-01-01';
```

查询子句中指定的字段必须是模型的一个字段名。不过也有个例外，在 [`ForeignKey`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ForeignKey) 中，你可以指定以 `_id` 为后缀的字段名。这种情况下，value 参数需要包含 foreign 模型的主键的原始值。例子：

```python
>>> Entry.objects.filter(blog_id=4)
```

以下是一些常见的查询：

- [`exact`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#std-fieldlookup-exact)

  一个 "exact" 匹配。例如

  ```python
  >>> Entry.objects.get(headline__exact="Cat bites dog")
  ```

  会生成这些 SQL：

  ```python
  SELECT ... WHERE headline = 'Cat bites dog';
  ```

  若你未提供查询类型 —— 也就说，若关键字参数未包含双下划线 —— 查询类型会被指定为 `exact`。

  例如，以下两个语句是等价的：

  ```python
  >>> Blog.objects.get(id__exact=14)  # Explicit form
  >>> Blog.objects.get(id=14)  # __exact is implied
  ```

- [`iexact`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#std-fieldlookup-iexact)

  不区分大小写的匹配

- [`contains`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#std-fieldlookup-contains)

  大小写敏感的包含测试。例子:

  `Entry.objects.get(headline__contains="Lennon")`

- [`startswith`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#std-fieldlookup-startswith), [`endswith`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#std-fieldlookup-endswith)

  以……开头和以……结尾的查找。当然也有大小写不敏感的版本，名为 [`istartswith`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#std-fieldlookup-istartswith) 和 [`iendswith`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#std-fieldlookup-iendswith)。

##### 跨关系查询[¶](https://docs.djangoproject.com/zh-hans/5.2/topics/db/queries/#lookups-that-span-relationships)

Django 提供了一种强大而直观的方式来“追踪”查询中的关系，在幕后自动为你处理 SQL `JOIN` 关系。为了跨越关系，跨模型使用关联字段名，字段名由双下划线分割，直到拿到想要的字段。

这个示例检索所有具有 `name` 为 `'Beatles Blog'` 的 `Blog` 的 `Entry` 对象：

```python
>>> Entry.objects.filter(blog__name="Beatles Blog")
```

它也可以反向工作。虽然它 [`可以自定义`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ForeignKey.related_query_name)，默认情况下，你在查找中使用模型的小写名称来引用一个 “反向” 关系。

这个示例检索所有至少有一个 `headline` 包含 `'Lennon'` 的 `Entry` 的 `Blog` 对象：

```python
>>> Blog.objects.filter(entry__headline__contains="Lennon")
```

如果你在跨多个关系进行筛选，而某个中间模型的没有满足筛选条件的值，Django 会将它当做一个空的（所有值都是 `NULL`）但是有效的对象。这样就意味着不会抛出错误。例如，在这个过滤器中:

```python
Blog.objects.filter(entry__authors__name="Lennon")
```

（假设有个关联的 `Author` 模型），若某项条目没有任何关联的 `author`，它会被视作没有关联的 `name`，而不是因为缺失 `author` 而抛出错误。大多数情况下，这就是你期望的。唯一可能使你迷惑的场景是在使用 [`isnull`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/querysets/#std-fieldlookup-isnull) 时。因此:

```python
Blog.objects.filter(entry__authors__name__isnull=True)
```

将会返回 `Blog` 对象，包含 `author` 的 `name` 为空的对象，以及那些 `entry` 的 `author` 为空的对象。若你不想要后面的对象，你可以这样写:

```python
Blog.objects.filter(entry__authors__isnull=False, entry__authors__name__isnull=True)
```

##### 跨多值关联[¶](https://docs.djangoproject.com/zh-hans/5.2/topics/db/queries/#spanning-multi-valued-relationships)

当跨越 [`ManyToManyField`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ManyToManyField) 或反查 [`ForeignKey`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/fields/#django.db.models.ForeignKey) （例如从 `Blog` 到 `Entry` ）时，对多个属性进行过滤会产生这样的问题：是否要求每个属性都在同一个相关对象中重合。我们可能会寻找那些在标题中含有 *“Lennon”* 的 2008 年的博客，或者我们可能会寻找那些仅有 2008 年的任何条目以及一些在标题中含有 *“Lennon”* 的较新或较早的条目。

要选择所有包含 2008 年至少一个标题中有 *"Lennon"* 的条目的博客（满足两个条件的同一条目），我们要写：

```python
Blog.objects.filter(entry__headline__contains="Lennon", entry__pub_date__year=2008)
```

##### 过滤器可以为模型指定字段

在之前的例子中，我们已经构建过的 `filter` 都是将模型字段值与常量做比较。但是，要怎么做才能将模型字段值与同一模型中的另一字段做比较呢？

Django 提供了 [`F 表达式`](https://docs.djangoproject.com/zh-hans/5.2/ref/models/expressions/#django.db.models.F) 实现这种比较。 `F()` 的实例充当查询中的模型字段的引用。这些引用可在查询过滤器中用于在同一模型实例中比较两个不同的字段。

例如，要找到所有具有比 pingback 更多评论的博客条目的列表，我们构建一个引用 pingback 计数的 `F()` 对象，并在查询中使用该 `F()` 对象：

```python
>>> from django.db.models import F
>>> Entry.objects.filter(number_of_comments__gt=F("number_of_pingbacks"))
```

