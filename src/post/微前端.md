## 微前端能解决什么问题

- 大型项目复杂度高，打包时间长
- 团队协作技术栈不统一
- 增量迁移

微前端就是将不同功能按照不同维度拆分成多个子应用，通过主应用来加载子应用

## 如何实现微前端

我们可以将一个应用划分为若干个子应用，将子应用打包成一个个模块，当路径切换时加载不同的子应用

### 实现微前端需要解决哪些问题

- 数据间如何通信
- 应用间如何隔离（js隔离和css隔离）

### 实现方案

#### iframe

- 通过iframe加载子应用
- 通信可以通过postMessage进行通信
- 完美的沙盒机制自带应用隔离

缺点： 用户体验差（弹窗只能在iframe中、滚动条、内部切换刷新就会丢失状态）

#### web Components

- 将前端应用分解为自定义HTML元素
- 基于customEvent实现通信
- Shadow DOM天生作用域隔离

缺点：兼容性差、学习成本高、调试困难、修改样式困难

#### single-spa

- single-spa通过路由劫持实现应用加载，采用SystemJS加载应用或则模块
- 基于props主子应用通信
- 无沙盒机制，需要自己实现JS沙盒以及CSS沙盒

缺点： 学习成本、无沙盒机制，需要对原有的应用进行改造，子应用间相同资源重复加载问题

#### 模块联邦

- 通过模块联邦将组件进行打包导出使用
- 共享模块的方式进行通信
- 无CSS沙盒和JS沙盒

## systemJs
### 原理
1. 动态扫描依赖映射表，加载依赖源
2. 通过script动态导入打包好的子应用JS文件，加载好后，子应用会执行`System.register`方法来注册子应用需要的依赖
3. 动态加载子应用需要的依赖，加载完成后通过快照获取`windows`上的全局依赖的对象
4. 通过子应用的setter方法给子应用注入依赖
5. 最后执行子应用的业务逻辑代码渲染子应用


## single-spa
### 原理
1. 基座应用是管理所有子应用的生命周期
2. 基座在初始化的时候会注册子应用
3. 当子应用的路由匹配到时，基座获取加载子应用的实例，然后获取并调用子应用的生命周期方法
4. 通过`hashchange`和 `popState`监听路由变化，当路由变化时，基座会先卸载子应用，然后加载新的子应用，新的子应用加载完成后，会调用子应用的`bootstrap`、`mount`方法，渲染子应用


 